{"title":"CSMAR 数据处理","markdown":{"yaml":{"title":"CSMAR 数据处理"},"headingText":"从 CAMAR 数据库下载 Excel 数据文件","containsRefs":false,"markdown":"\n\n\n\n\nCSMAR (China Stock Market & Accounting Research) 是一个提供中国上市公司数据的数据库。本文将介绍如何使用 CSMAR 数据库获取上市公司基本信息和财务资料，并经过合并、清洗等处理，得到清洁数据。\n\n\n\n::: {.callout-note}\n### `.csv` 优于 `.xlsx`\n\n我此前对 Python 处理数据的机制了解不足，导致我最初下载的都是 `.xlsx` 格式的数据。虽然这种 Excel 格式的数据可以使用 `pandas` 读取，但非常耗时 (一份包含 8w 行观察值的资产负债表大概需要 50s)。相比之下，`.csv` 格式的数据读取速度更快，通常只需要几秒钟。\n \n因此，大家从 CSMAR 数据库下载数据时，建议选择 `.csv` 格式，而不是 `.xlsx` 格式。\n:::\n\n\n### 数据下载页面\n\n- 网址：<https://data.csmar.com/>\n- 登录：中大 IP 地址范围内自动登录 (机构账号)\n\n<img style=\"width: 400px\" src=\"https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250528000207.png\">\n\n主要有两种查询方案：\n\n- **单表查询**：直接查询某一张表格的数据。\n- **多表查询**：可以跨表查询，形成一个新的表格。\n\n两种模式下的查询流程大致相同：选择子库 >> 选择时间范围 >> 选择代码范围 >> 选择字段范围 >> 下载数据。\n\n建议尽量选择 `.csv` 或 `.txt` 格式下载数据，因为这两种格式的数据读取速度更快。\n\n\n下载后的文件通常为 **.zip** 格式，解压后会得到两份文件：\n- `FileName.csv`: 数据文件\n- `FileName[DES][xlsx].txt`: 变量说明文件\n\n数据库说明书：每个子库的右上角都会显示「**[数据库说明书](https://data.csmar.com/lib/pdfjs/web/viewer.html?file=group1%2FM00%2F3F%2FF2%2FCuIKV2c8MBmASlKhABdnboBfW5s152.pdf&fname=%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%B4%E6%98%8E%E4%B9%A6)**」，点击后可下载 PDF 格式的说明书，里面包含了该子库的所有表格、字段的详细信息。\n\n<img style=\"width: 650px\" src=\"https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250528001925.png\">\n\n\n\n## 文件夹结构与处理流程说明\n\n本项目的数据处理涉及以下文件夹：\n\n- **data_raw_zip**：存放从 CSMAR 下载的原始数据（.zip 压缩包），每个压缩包解压后会生成同名文件夹。\n- **data_raw**：存放解压后的原始数据文件。\n- **data_clean**：存放清洗后的数据文件。\n\n### 处理流程\n\n1. 列出 `data_raw_zip` 文件夹中的所有压缩文件。\n2. 将每个压缩包解压到 `data_raw` 文件夹下，解压后以压缩包同名文件夹存放。\n3. 为便于后续批量处理，对解压后的文件进行统一重命名。\n4. 编写函数，实现指定文件夹下文件的批量读取。\n\n\n## 解压 zip 文件到指定文件夹\n\n::: {.callout-tip}\n### 提示词\n\n- 将当前路径下的 'data_raw_zip' 文件夹中的所有 zip 文件解压到 'data_raw' 文件夹中。\n- 如果 'data_raw' 文件夹不存在，则创建该文件夹。\n- 每个 zip 文件解压后生成一个文件夹，文件夹名称与 zip 文件名相同，若有同名文件则覆盖之。\n  \n:::\n\n## 更改部分文件夹中的文件名\n\n### 问题说明\n\n在 `data_raw` 文件夹中，有些子文件夹中的文件名是由 CSMAR 自动生成的，没有实际意义。为了便于后续处理，需要将这些文件名更改为更有意义的名称。\n\n此处以 `data_raw/资产负债表-??` 文件夹为例，可以看出，`资产负债表-2000-2010` 和 `资产负债表-2011-2024` 这两个文件夹中包含的文件名完全相同，这会导致随后纵向合并时难以区分数据来源。\n\n\n\n查看后，发现子文件夹 `利润表-现金流量表-??` 和 `CSMAR常用变量-2000-2024` 中的文件名也存在类似问题。\n\n处理思路是：用文件夹名称作为该文件夹下的文件的文件名。因此，我们可以使用如下提示词生成处理代码：\n\n::: {.callout-tip}\n### 提示词\n\n1. 目的：更改 'data_raw' 文件夹中部分子文件夹中的文件的名称。\n2. 子文件夹名称为 'sub_folder_name'，其内部包含的文件记为 {Files} \n3. 如果 'sub_folder_name' 中包含关键词 {'常用变量', '资产负债表', '利润表'}，则把 {Files} 中的 '.xlsx' 和 '.txt' 文件的名称改为 'folder_name.xlsx' 和 'folder_name_DES.txt'。\n\n:::\n\n### 查看处理后的文件名\n\n## 列示 'data_raw' 文件夹中的 file tree\n\n::: {.callout-tip}\n### 提示词\n\n- 列示 'data_raw' 文件夹中的文件树结构。\n- 只列示文件夹名称和文件名称，不需要显示文件内容。\n- 如果文件夹中有子文件夹，则显示子文件夹名称。\n\n:::\n\n## 定义函数以批量读取指定文件夹下的文件\n\n### 文件内容分析\n\n观察后发现，每个文件夹下都包含两个文件：\n\n- `*.xlsx`：包含数据的 Excel 文件。\n- `*DES*.txt`：包含数据描述的文本文件。\n\n我们可以查看这两份文件的内容和结构，然后再决定读取方案。这里仍以 [资产负债表-2011-2024] 文件夹为例进行说明。\n\n**`资产负债表-2011-2024.xlsx`** 是数据文件，存储结构如下：前 6 列和前 9 行数据如下：\n\n<img style=\"width: 650px\" src=\"https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250526115914.png\">\n\n可以看出，从第 5 行开始是具体的观察值，而此前的四行则是表头信息：\n\n- 第一行是变量名\n- 第二行是变量的中文简称 (可以用作变量中文标签)\n- 第三行是变量的单位\n- 第四行是变量的其他说明信息。如第 5-6 列显示的是报表类型。\n\n`资产负债表-2011-2024_DES.txt` 是变量描述文件，主要包含变量的中文名称、单位、数据来源等信息。其原始内容如下：\n\n```raw\n-------------------- 资产负债表-2011-2024_DES.txt ---------begin--\n本信息:\ncode[证券代码] - \nstknme[证券简称] - \nlistingDate[上市日期] - \nEndDate[时间] - \n\n数据库名称：财务报表--> 表名称：资产负债表(FS_Combas)\nA001101000[货币资金] - 公司库存现金、银行结算户存款、……等的合计数。1990年起使用\nA001107000[交易性金融资产] - 交易性金融资产是……的债券投资、股票投资……。2007年起使用。\n……\n-------------------- 资产负债表-2011-2024_DES.txt ---------over--\n```\n\n可以看出，`资产负债表-2011-2024_DES.txt` 文件中每行的格式为：\n\n\n`varname`[**中文简称**] - *变量说明* \n\n- `varname` 是变量的英文名称。\n- `中文简称` 是变量的中文名称，可以作为变量标签。\n- `变量说明` 是对该变量的详细描述，包括变量的含义、计算方法、单位、数据来源等信息。\n\n\n对比这两份文件，有如下几种处理方案：\n\n**方案 1**：简化版\n\n如果只需要 `varname` 和 `中文简称` (后者可以作为前者的变量标签)，则处理过程为：\n\n**input**：`资产负债表-2011-2024.xlsx`  \n\n- 提取 `资产负债表-2011-2024.xlsx` 文件中第 5 行以后的所有数据，定义为数据框 `df`；\n- 提取 `资产负债表-2011-2024.xlsx` 前两行数据，定义为一个字典 **dict** - `{varname: 中文简称}`；\n- 将该字典附加到数据框 `df` 中，作为它的一个属性。\n\n**output**：`df` 数据框 + `dict` 字典。\n\n这种处理方式的好处是只需要数据文件 `资产负债表-2011-2024.xlsx`，缺陷是使用数据时，如果想知道每个变量详细信息，就需要翻阅 CSMAR 提供的 PDF 说明书，或 `资产负债表-2011-2024_DES.txt` 文件。\n\n**方案 2**：完整信息版\n\n此版本的思路是把变量的中文名和变量说明信息都提取出来，制作成两个字典，整合到数据框中。其好处是，我们可以随时在 Python 内部查看变量的中文名称和说明信息，而不需要翻阅 PDF 或其他文件。\n\n处理过程如下：\n\n**input**：`资产负债表-2011-2024.xlsx` + `资产负债表-2011-2024_DES.txt`\n \n- 提取 `资产负债表-2011-2024.xlsx` 文件中第 5 行以后的所有数据，定义为数据框 `df`；\n- 从 `资产负债表-2011-2024_DES.txt` 文件中提取信息，定义两个字典：\n  - 字典 1：`{varname: 中文简称}`，用于将英文变量名与其中文简称对应起来。\n  - 字典 2：`{varname: 变量说明}`，用于将英文变量名与其详细说明对应起来。\n- 将这两个字典附加到数据框 `df` 中，作为它的两个属性。\n\n**output**：`df` 数据框 + `dict1` 字典 + `dict2` 字典。\n\n\n**方案 3**：简化版-中文变量名\n\n如果已经对变量名有了充分了解，且只需要 `中文简称`，则处理过程为：\n\n**input**：`资产负债表-2011-2024.xlsx`\n\n- 读入 `资产负债表-2011-2024.xlsx` 文件中第 2 行以后的所有数据，定义为数据框 `df`；\n- 删除数据框 `df` 中的第 2-3 行；\n\n上述方案的对比：\n\n- **方案 1**：只保留英文变量名和中文简称，适用于对 CSMAR 数据库比较熟悉的用户。\n- **方案 2**：保留英文变量名、中文简称和变量说明，适用于需要详细了解变量含义的用户。\n- **方案 3**：只保留中文简称，变量含义直观明了。缺陷是，有些变量的中文简称中包含了 `(`，`（`，` ` 等特殊字符，需要额外转换。因此，不太推荐这种方式。\n\n下面，我们将实现方案 1 的处理过程。\n\n### 方案 1：简化版处理代码\n\n处理思路：\n\n从 CSMAR 下载下来的每个 .zip 文件解压后，都会生成一个同名文件夹 (记为 `'folder_path'`)。该文件夹下包含一个 .xlsx 格式的数据文件和一个 .txt 格式的描述文件。因此，我们只需要指定 `'folder_path'`，便可以让 Python 根据文件后缀自动识别并读取这两个文件。对于 **方案 1**，我们只需要读取 .xlsx 文件，并将该文件的第二行作为变量 (第一行) 的中文标签即可。\n\n::: {.callout-tip}\n### 提示词\n\n- 目的：读取指定文件夹下的 Excel 文件，并将其第二行作为变量的中文标签。\n\n- input：folder = '资产负债表-2011-2024'\n  - folder_path = '{path}/data_raw/{folder}'\n  - {path} 已经在第一个 cell ('文件路径设定{tag}') 中定义\n\n- 处理思路：\n\n  - 检查该文件夹下以 `.xlsx` 结尾的文件的个数，如果大于 1 个，则报错。\n  - 读入该文件夹下以 `.xlsx` 结尾的文件。完整文件名为：`{filename}.xlsx`。\n  - 存入数据框 `df_filename`。\n    - 打印 forder_path 和 df_filename 的名称\n  - 删除 Excel 表格第 3 行和第 4 行\n  - 做一个字典：`dict_filename`，键为英文变量名，值为中文变量名。\n    - key: 英文变量名，从 Excel 第 1 行提取。\n    - value: 中文变量名，从 Excel 第 2 行提取。\n  - 将 `dict_filename` 附加到 `df_filename` 数据框中，作为它的一个属性。\n  - 删除第 2 行\n  \n- 显示处理后的数据框 `df_filename`.head() 的前 5 列和字典 `dict_filename` 的全部 {key: value}。\n  \n:::\n\n### 优化代码\n\n上述代码可以一次性顺利执行，但耗时为 53s，太慢。于是，我把上述提示词和代码发给了 ChatGPT，请它优化代码。它给出的建议是：pandas 读取 `.xlsx` 格式本身就比较慢，尤其是数据量大或格式复杂时，速度瓶颈主要在于底层解析 Excel 文件的过程。此外，上述代码读取了两次 Excel 文件，第一次读取是为了获取变量名和中文简称，第二次读取是为了获取数据，这样会导致重复的 I/O 操作，进一步降低速度。\n\n应对方法是，先使用 **xlsx2csv** 包将 `.xlsx` 文件快速转换为 `.csv` 格式，然后再用 **pandas** 的 `read_csv` 读取数据，这样可以极大提升读取速度。\n\n优化后的代码只需 1-2 秒即可完成 ([ChatGPT 提示词](https://chatgpt.com/share/6834a1eb-b8fc-8005-a555-045a3986aeec))：\n\n\n::: {.callout-tip}\n### 提示词\n\n目标：定义一个函数 `read_files_in_folder(folder_path, Fname=None)`，用于批量读取指定文件夹下的 .xlsx 文件，并返回数据框和变量名-中文名字典。\n\n要求：\n\n1. 参数说明：\n    - `folder_path`：字符串，指定要读取的文件夹路径。\n    - `Fname`：字符串，可选，指定数据框和字典的名称前缀。若为 None，则自动取 .xlsx 文件名（不含扩展名），并将特殊字符替换为下划线。\n2. 处理流程：\n    - 检查文件夹下以 `.xlsx` 结尾且不以 `~$` 开头的文件，若数量不为 1，则报错。\n    - 将 .xlsx 文件转换为 .csv 文件（如已存在则跳过），转换时编码为 gbk。\n    - 读取 .csv 文件前 4 行，提取英文变量名和中文变量名。\n    - 对英文变量名，若为 'A-B' 结构，则只保留 B 部分。\n    - 构建 {英文变量名: 中文变量名} 的字典。\n    - 跳过前 4 行读取正文数据，列名用处理后的英文变量名。\n    - 返回一个 dict，包含数据框（键名为 `df_{Fname}`）和变量名字典（键名为 `dic_{Fname}`）。\n3. 代码需包含必要的 import，且不重复导入已在 notebook 其他 cell 导入的模块。\n4. 代码块必须完整、可直接运行。\n\n:::\n\n## 定义函数以批量读取指定文件夹下的文件\n\n几个要点：\n\n- 这个提示词还需修改：目前的提示词不具有独立性，应该与上一个 Cell 的提示词合并。\n- 变量名的处理：在 '利润表-现金流量表xxx.csv' 和 '资产负债表xxx.csv' 文件中，变量名的格式为 'A-B'，我们需要删除 'A-' 部分，只保留 'C' 部分。\n  - `FS_Combas-A001101000: 货币资金` 变为 `A001101000: 货币资金`\n  - `FS_Comins-B003000000: 基本每股收益` 变为 `B003000000: 基本每股收益`\n  - `FS_Comscfd-C001021000: 支付的各项税费` 变为 `C001021000: 支付的各项税费`\n\n::: {.callout-tip}\n### 提示词\n\n- 以 {tag}: 'read_xlsx_example' Cell 中的代码为基础，定义一个函数 `read_files_in_folder(folder_path, Fname)`，用于批量读取指定文件夹下的所有文件。\n  - 函数参数 `folder_path` 是一个字符串，表示要读取的文件夹路径。\n  - `Fname` 是一个字符串，表示文件夹的名称，用于生成数据框和字典的名称。如果用户不指定，则默认使用 `.xlsx` 文件的名称，特殊字符采用 `_` 替换，确保符合 Python 命名规则。\n  - 如果变量名为 `A-B` 结构，则删除 'A-' 部分，只保留 'B' 部分。\n- 函数返回：一个数据框，名称为 `df_{Fname}`；一个字典，用于存储 {变量名: 变量中文简称}，名称为 `dic_{Fname}`。\n\n:::\n\n## 批量处理\n\n接下来，我们就可以用上面定义的函数来批量处理 `data_raw` 文件夹中的所有子文件夹了。\n\n::: {.callout-tip}\n### 提示词\n\n用 {tag}: 'fcn_read_files_in_folder' Cell 中定义的 `read_files_in_folder()` 函数批量读取 `data_raw` 文件夹中的所有子文件夹下的文件，并将结果存储到 `data_clean` 文件夹中。主要步骤如下：\n\n- 如果 `data_clean` 文件夹不存在，则创建该文件夹；如果已经存在，则清空该文件夹中的所有内容。\n- 遍历 `data_raw` 文件夹中的所有子文件夹。\n  - 对于每个子文件夹，调用 `read_files_in_folder` 函数，读取其中的 `.xlsx` 文件和 `.txt` 文件。\n  - 将读取到的数据框和字典保存到 `data_clean` 文件夹中，文件名为 `{子文件夹名称}.pkl`。\n\n:::\n\n### 查看导入结果\n\n::: {.callout-tip}\n### 提示词\n\n列出 `data_clean` 文件夹中的所有文件，以及每个文件的对应字典的前五个 {key: value}\n\n:::\n\n简要分析：\n\n考虑到随后要将这些文件合并为一个数据框，我们需要重点关注如下几点：\n\n- `上市公司基本信息变更表2000-2024.pkl` 暂时用不到，不予处理。\n- 哪些文件需要纵向合并 (append)?\n  - `利润表-现金流量表-xxx.pkl` 和 `资产负债表-xxx.pkl` 这两类文件需要纵向合并，分别存入数据框 `df_profit` 和 `df_asset` 中。\n- 哪些文件需要横向合并 (merge)?\n  - 将 `df_profit` 和 `df_asset` 横向合并为一个数据框 `df_financial`；\n  - 进而与 `CSMAR常用变量-2000-2024.pkl` 和 `上市公司基本信息年度表.pkl` 横向合并，得到最终的数据框 `df_final`。\n- 横向合并时，需要保证两份数据中有相同的变量名 (keys)。由于我们要合并的数据都是 'firm-year' 格式的面板数据，因此需要保证每个数据框中都有 'code' 和 'year' 这两个变量。\n  - 我们需要为 `CSMAR常用变量-2000-2024.pkl` 和 `上市公司基本信息年度表.pkl` 这两份文件添加 'code'  和 'year' 变量。二者分别对应这三个数据文件中的 `Symbol` 和 `EndDate` 变量。\n  - 对于 `利润表-现金流量表-xxx.pkl` 和 `资产负债表-xxx` 文件，需要将 `EndDate` 变量转换为 `year` 变量，以便后续合并。\n\n### 查看处理后的单个文件\n\n::: {.callout-tip}\n### 提示词\n\n- 列示 'CSMAR常用变量-2000-2024.pkl' 中的所有对象；\n- 空一行+分隔线；\n- 列示 'CSMAR常用变量-2000-2024.pkl' 的 shape；\n- 空一行+分隔线；\n- 列示 'CSMAR常用变量-2000-2024.pkl' 数据框中的 '前五行+前五列'；\n- 空一行+分隔线；\n- 列示字典中的所有 {变量名：中文简称}。\n\n:::\n\n## 合并数据\n\n### 纵向合并\n\n::: {.callout-tip}\n### 提示词\n\n== 纵向合并不同年度的同名文件\n\n- 纵向合并 `data_clean` 文件夹中所有以 '资产负债表' 开头的文件。\n  - 将 `EndDate` 列重命名为 `year` 列。\n  - 合并后的数据框命名为 `df_assets`，并保存到 `data_clean` 文件夹中，文件名为 `df_assets.pkl`。\n- 纵向合并 `data_clean` 文件夹中所有以 '利润表' 开头的文件。\n  - 将 `EndDate` 列重命名为 `year` 列。\n  - 合并后的数据框命名为 `df_profit`，并保存到 `data_clean` 文件夹中，文件名为 `df_profit.pkl`。\n- 上述合并完成后，打印合并后的数据框的 shape；展示 '前三行 + 前五列'。\n\n:::\n\n### 横向合并\n\n::: {.callout-tip}\n### 提示词\n\n== 横向合并不同来源的数据\n\n1. 一些出现两次以上的功能，可以预先定义函数，确保代码结构清晰\n2. 资产负债表与利润表的合并\n  - 读入 `data_clean` 文件夹中的 `df_assets.pkl`。\n  - 按照关键词 '{code, year}' 与 `df_profit.pkl` 数据框横向合并；\n    - 如果有同名变量，则自动忽略。\n  - 合并后的数据存入数据框 `df_financial`;\n  - 数据框的前两列变量为 'code, year'\n3. 继续与 `上市公司基本信息年度表`, `CSMAR常用变量-2000-2024.pkl` 数据框横向合并。\n  - 合并前，先将 `上市公司基本信息年度表.pkl` 中的 `Symbol` 列重命名为 `code`，`EndDate` 列重命名为 `year`。\n  - 按照关键词 '{code, year}' 与 `df_financial` 数据框横向合并；\n    - 如果有同名变量，则自动忽略。\n4. 输出合并后的数据文件\n  - 合并后的数据存入数据框 `df_final`，\n    - 第一列为 'code'，第二列为 'year'，是两个独立的变量。\n    - 保存到 `data_clean` 文件夹中，文件名为 `df_final.pkl`。\n  - 最终数据框 `df_final` 的前两列变量为 'code, year'，并展示其 shape 和 '前三行 + 前五列'。\n5. 合并数据字典。将上述文件的字典合并为一个大字典 `dict_CSMAR`。\n  - 同名变量的中文简称和说明信息取先进入的文件的。 \n6. 打印数据字典尺寸，以及前十行信息，格式：{变量名: 中文简称}；\n7. 每组打印结果之间空一行，添加标题文字和分割线   \n\n:::\n\n### 输出最终数据文件\n\n::: {.callout-tip}\n### 提示词\n\n== 输出 csv 和 txt 文件到 [data_final] 文件夹\n\n1. 将 `df_final` 数据框保存为 `CSMAR_final.csv` 文件，存储在 [data_final] 文件夹中。\n2. 将 `dict_CSMAR` 字典保存为 `CSMAR_var_label.txt` 文件，存储在 [data_final] 文件夹中。每行格式为：`变量名: 中文简称`。\n\n:::\n\n### 收尾：删除无用文件和过程文件\n\n> Note：这一步是可选的，主要是为了清理不必要的文件，以节省存储空间和提高数据处理效率。  \n> 建议：确认所有数据处理和合并工作完成后，再执行此步骤。\n\n有些过程文件已经不需要了：\n\n-  `data_raw` 文件夹中的 `.xlsx` 文件已经转换为 `.csv` 文件，因此可以删除。\n-  `data_clean` 文件夹中的一些文件也不需要了，如 `利润表-现金流量表-xxx.pkl` 和 `资产负债表-xxx.pkl`，因为它们已经被合并为 `df_financial.pkl`。\n\n\n::: {.callout-tip}\n### 提示词\n\n- 删除 `data_raw` 文件夹中所有子文件夹中的 `.xlsx` 文件。\n- 删除 `data_clean` 文件夹中如下文件：\n  - 以 `利润表-现金流量表-` 开头的文件；\n  - 以 `资产负债表-` 开头的文件；\n  \n:::\n\n### 呈现项目文档树\n\n要点：\n\n- 代码执行后会自动将工作目录切换回项目根目录，确保后续操作路径一致。\n\n::: {.callout-tip}\n### 提示词\n\n- 列示项目文档树结构。\n- 只列示文件夹名称和文件名称，不需要显示文件内容。\n- 如果文件夹中有子文件夹，则显示子文件夹名称。\n- 处理完后，将工作目录切换到项目根目录。\n- 为此代码块添加标题和合适的注释。\n\n:::\n\n### 保留哪些文件夹？\n\n在本地运行完毕后，项目根目录下会包含如下文件夹：\n\n- [1] `data_raw_zip` 文件夹：**务必保留**，里面存放了从 CSMAR 下载的原始数据压缩包。\n- [2] `data_raw` 文件夹：**可以删除**，里面存放了解压后的 .xlsx 和 .txt 文档\n- [3] `data_clean` 文件夹：**酌情删除**，里面存放了清洗后的 `.pkl` 文件。\n- [4] `data_final` 文件夹：**建议保留**，里面存放了最终的 `.csv` 和 `.txt` 文件。\n\n可复现文档分享方案：\n\n一旦确定上述代码无误，在分享时，只需保留 `01_read_merge.ipynb` 文件和 `[data_raw_zip]` 文件夹即可。\n\n- 完整复现文档：\n  - `01_read_merge.ipynb` 文件：包含了从数据读取到合并的完整代码。\n  - `[data_raw_zip]` 文件夹：包含了从 CSMAR 下载的原始数据压缩包。\n- 直接使用最终文档 + 了解处理过程：\n  - `data_final` 文件夹：包含了最终的 `.csv` 和 `.txt` 文件，便于直接使用。\n  - `01_read_merge.ipynb` 文件：包含了从数据读取到合并的完整代码。\n","srcMarkdownNoYaml":"\n\n\n\n\nCSMAR (China Stock Market & Accounting Research) 是一个提供中国上市公司数据的数据库。本文将介绍如何使用 CSMAR 数据库获取上市公司基本信息和财务资料，并经过合并、清洗等处理，得到清洁数据。\n\n\n## 从 CAMAR 数据库下载 Excel 数据文件\n\n::: {.callout-note}\n### `.csv` 优于 `.xlsx`\n\n我此前对 Python 处理数据的机制了解不足，导致我最初下载的都是 `.xlsx` 格式的数据。虽然这种 Excel 格式的数据可以使用 `pandas` 读取，但非常耗时 (一份包含 8w 行观察值的资产负债表大概需要 50s)。相比之下，`.csv` 格式的数据读取速度更快，通常只需要几秒钟。\n \n因此，大家从 CSMAR 数据库下载数据时，建议选择 `.csv` 格式，而不是 `.xlsx` 格式。\n:::\n\n\n### 数据下载页面\n\n- 网址：<https://data.csmar.com/>\n- 登录：中大 IP 地址范围内自动登录 (机构账号)\n\n<img style=\"width: 400px\" src=\"https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250528000207.png\">\n\n主要有两种查询方案：\n\n- **单表查询**：直接查询某一张表格的数据。\n- **多表查询**：可以跨表查询，形成一个新的表格。\n\n两种模式下的查询流程大致相同：选择子库 >> 选择时间范围 >> 选择代码范围 >> 选择字段范围 >> 下载数据。\n\n建议尽量选择 `.csv` 或 `.txt` 格式下载数据，因为这两种格式的数据读取速度更快。\n\n\n下载后的文件通常为 **.zip** 格式，解压后会得到两份文件：\n- `FileName.csv`: 数据文件\n- `FileName[DES][xlsx].txt`: 变量说明文件\n\n数据库说明书：每个子库的右上角都会显示「**[数据库说明书](https://data.csmar.com/lib/pdfjs/web/viewer.html?file=group1%2FM00%2F3F%2FF2%2FCuIKV2c8MBmASlKhABdnboBfW5s152.pdf&fname=%E8%B4%A2%E5%8A%A1%E6%8A%A5%E8%A1%A8%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%B4%E6%98%8E%E4%B9%A6)**」，点击后可下载 PDF 格式的说明书，里面包含了该子库的所有表格、字段的详细信息。\n\n<img style=\"width: 650px\" src=\"https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250528001925.png\">\n\n\n\n## 文件夹结构与处理流程说明\n\n本项目的数据处理涉及以下文件夹：\n\n- **data_raw_zip**：存放从 CSMAR 下载的原始数据（.zip 压缩包），每个压缩包解压后会生成同名文件夹。\n- **data_raw**：存放解压后的原始数据文件。\n- **data_clean**：存放清洗后的数据文件。\n\n### 处理流程\n\n1. 列出 `data_raw_zip` 文件夹中的所有压缩文件。\n2. 将每个压缩包解压到 `data_raw` 文件夹下，解压后以压缩包同名文件夹存放。\n3. 为便于后续批量处理，对解压后的文件进行统一重命名。\n4. 编写函数，实现指定文件夹下文件的批量读取。\n\n\n## 解压 zip 文件到指定文件夹\n\n::: {.callout-tip}\n### 提示词\n\n- 将当前路径下的 'data_raw_zip' 文件夹中的所有 zip 文件解压到 'data_raw' 文件夹中。\n- 如果 'data_raw' 文件夹不存在，则创建该文件夹。\n- 每个 zip 文件解压后生成一个文件夹，文件夹名称与 zip 文件名相同，若有同名文件则覆盖之。\n  \n:::\n\n## 更改部分文件夹中的文件名\n\n### 问题说明\n\n在 `data_raw` 文件夹中，有些子文件夹中的文件名是由 CSMAR 自动生成的，没有实际意义。为了便于后续处理，需要将这些文件名更改为更有意义的名称。\n\n此处以 `data_raw/资产负债表-??` 文件夹为例，可以看出，`资产负债表-2000-2010` 和 `资产负债表-2011-2024` 这两个文件夹中包含的文件名完全相同，这会导致随后纵向合并时难以区分数据来源。\n\n\n\n查看后，发现子文件夹 `利润表-现金流量表-??` 和 `CSMAR常用变量-2000-2024` 中的文件名也存在类似问题。\n\n处理思路是：用文件夹名称作为该文件夹下的文件的文件名。因此，我们可以使用如下提示词生成处理代码：\n\n::: {.callout-tip}\n### 提示词\n\n1. 目的：更改 'data_raw' 文件夹中部分子文件夹中的文件的名称。\n2. 子文件夹名称为 'sub_folder_name'，其内部包含的文件记为 {Files} \n3. 如果 'sub_folder_name' 中包含关键词 {'常用变量', '资产负债表', '利润表'}，则把 {Files} 中的 '.xlsx' 和 '.txt' 文件的名称改为 'folder_name.xlsx' 和 'folder_name_DES.txt'。\n\n:::\n\n### 查看处理后的文件名\n\n## 列示 'data_raw' 文件夹中的 file tree\n\n::: {.callout-tip}\n### 提示词\n\n- 列示 'data_raw' 文件夹中的文件树结构。\n- 只列示文件夹名称和文件名称，不需要显示文件内容。\n- 如果文件夹中有子文件夹，则显示子文件夹名称。\n\n:::\n\n## 定义函数以批量读取指定文件夹下的文件\n\n### 文件内容分析\n\n观察后发现，每个文件夹下都包含两个文件：\n\n- `*.xlsx`：包含数据的 Excel 文件。\n- `*DES*.txt`：包含数据描述的文本文件。\n\n我们可以查看这两份文件的内容和结构，然后再决定读取方案。这里仍以 [资产负债表-2011-2024] 文件夹为例进行说明。\n\n**`资产负债表-2011-2024.xlsx`** 是数据文件，存储结构如下：前 6 列和前 9 行数据如下：\n\n<img style=\"width: 650px\" src=\"https://fig-lianxh.oss-cn-shenzhen.aliyuncs.com/20250526115914.png\">\n\n可以看出，从第 5 行开始是具体的观察值，而此前的四行则是表头信息：\n\n- 第一行是变量名\n- 第二行是变量的中文简称 (可以用作变量中文标签)\n- 第三行是变量的单位\n- 第四行是变量的其他说明信息。如第 5-6 列显示的是报表类型。\n\n`资产负债表-2011-2024_DES.txt` 是变量描述文件，主要包含变量的中文名称、单位、数据来源等信息。其原始内容如下：\n\n```raw\n-------------------- 资产负债表-2011-2024_DES.txt ---------begin--\n本信息:\ncode[证券代码] - \nstknme[证券简称] - \nlistingDate[上市日期] - \nEndDate[时间] - \n\n数据库名称：财务报表--> 表名称：资产负债表(FS_Combas)\nA001101000[货币资金] - 公司库存现金、银行结算户存款、……等的合计数。1990年起使用\nA001107000[交易性金融资产] - 交易性金融资产是……的债券投资、股票投资……。2007年起使用。\n……\n-------------------- 资产负债表-2011-2024_DES.txt ---------over--\n```\n\n可以看出，`资产负债表-2011-2024_DES.txt` 文件中每行的格式为：\n\n\n`varname`[**中文简称**] - *变量说明* \n\n- `varname` 是变量的英文名称。\n- `中文简称` 是变量的中文名称，可以作为变量标签。\n- `变量说明` 是对该变量的详细描述，包括变量的含义、计算方法、单位、数据来源等信息。\n\n\n对比这两份文件，有如下几种处理方案：\n\n**方案 1**：简化版\n\n如果只需要 `varname` 和 `中文简称` (后者可以作为前者的变量标签)，则处理过程为：\n\n**input**：`资产负债表-2011-2024.xlsx`  \n\n- 提取 `资产负债表-2011-2024.xlsx` 文件中第 5 行以后的所有数据，定义为数据框 `df`；\n- 提取 `资产负债表-2011-2024.xlsx` 前两行数据，定义为一个字典 **dict** - `{varname: 中文简称}`；\n- 将该字典附加到数据框 `df` 中，作为它的一个属性。\n\n**output**：`df` 数据框 + `dict` 字典。\n\n这种处理方式的好处是只需要数据文件 `资产负债表-2011-2024.xlsx`，缺陷是使用数据时，如果想知道每个变量详细信息，就需要翻阅 CSMAR 提供的 PDF 说明书，或 `资产负债表-2011-2024_DES.txt` 文件。\n\n**方案 2**：完整信息版\n\n此版本的思路是把变量的中文名和变量说明信息都提取出来，制作成两个字典，整合到数据框中。其好处是，我们可以随时在 Python 内部查看变量的中文名称和说明信息，而不需要翻阅 PDF 或其他文件。\n\n处理过程如下：\n\n**input**：`资产负债表-2011-2024.xlsx` + `资产负债表-2011-2024_DES.txt`\n \n- 提取 `资产负债表-2011-2024.xlsx` 文件中第 5 行以后的所有数据，定义为数据框 `df`；\n- 从 `资产负债表-2011-2024_DES.txt` 文件中提取信息，定义两个字典：\n  - 字典 1：`{varname: 中文简称}`，用于将英文变量名与其中文简称对应起来。\n  - 字典 2：`{varname: 变量说明}`，用于将英文变量名与其详细说明对应起来。\n- 将这两个字典附加到数据框 `df` 中，作为它的两个属性。\n\n**output**：`df` 数据框 + `dict1` 字典 + `dict2` 字典。\n\n\n**方案 3**：简化版-中文变量名\n\n如果已经对变量名有了充分了解，且只需要 `中文简称`，则处理过程为：\n\n**input**：`资产负债表-2011-2024.xlsx`\n\n- 读入 `资产负债表-2011-2024.xlsx` 文件中第 2 行以后的所有数据，定义为数据框 `df`；\n- 删除数据框 `df` 中的第 2-3 行；\n\n上述方案的对比：\n\n- **方案 1**：只保留英文变量名和中文简称，适用于对 CSMAR 数据库比较熟悉的用户。\n- **方案 2**：保留英文变量名、中文简称和变量说明，适用于需要详细了解变量含义的用户。\n- **方案 3**：只保留中文简称，变量含义直观明了。缺陷是，有些变量的中文简称中包含了 `(`，`（`，` ` 等特殊字符，需要额外转换。因此，不太推荐这种方式。\n\n下面，我们将实现方案 1 的处理过程。\n\n### 方案 1：简化版处理代码\n\n处理思路：\n\n从 CSMAR 下载下来的每个 .zip 文件解压后，都会生成一个同名文件夹 (记为 `'folder_path'`)。该文件夹下包含一个 .xlsx 格式的数据文件和一个 .txt 格式的描述文件。因此，我们只需要指定 `'folder_path'`，便可以让 Python 根据文件后缀自动识别并读取这两个文件。对于 **方案 1**，我们只需要读取 .xlsx 文件，并将该文件的第二行作为变量 (第一行) 的中文标签即可。\n\n::: {.callout-tip}\n### 提示词\n\n- 目的：读取指定文件夹下的 Excel 文件，并将其第二行作为变量的中文标签。\n\n- input：folder = '资产负债表-2011-2024'\n  - folder_path = '{path}/data_raw/{folder}'\n  - {path} 已经在第一个 cell ('文件路径设定{tag}') 中定义\n\n- 处理思路：\n\n  - 检查该文件夹下以 `.xlsx` 结尾的文件的个数，如果大于 1 个，则报错。\n  - 读入该文件夹下以 `.xlsx` 结尾的文件。完整文件名为：`{filename}.xlsx`。\n  - 存入数据框 `df_filename`。\n    - 打印 forder_path 和 df_filename 的名称\n  - 删除 Excel 表格第 3 行和第 4 行\n  - 做一个字典：`dict_filename`，键为英文变量名，值为中文变量名。\n    - key: 英文变量名，从 Excel 第 1 行提取。\n    - value: 中文变量名，从 Excel 第 2 行提取。\n  - 将 `dict_filename` 附加到 `df_filename` 数据框中，作为它的一个属性。\n  - 删除第 2 行\n  \n- 显示处理后的数据框 `df_filename`.head() 的前 5 列和字典 `dict_filename` 的全部 {key: value}。\n  \n:::\n\n### 优化代码\n\n上述代码可以一次性顺利执行，但耗时为 53s，太慢。于是，我把上述提示词和代码发给了 ChatGPT，请它优化代码。它给出的建议是：pandas 读取 `.xlsx` 格式本身就比较慢，尤其是数据量大或格式复杂时，速度瓶颈主要在于底层解析 Excel 文件的过程。此外，上述代码读取了两次 Excel 文件，第一次读取是为了获取变量名和中文简称，第二次读取是为了获取数据，这样会导致重复的 I/O 操作，进一步降低速度。\n\n应对方法是，先使用 **xlsx2csv** 包将 `.xlsx` 文件快速转换为 `.csv` 格式，然后再用 **pandas** 的 `read_csv` 读取数据，这样可以极大提升读取速度。\n\n优化后的代码只需 1-2 秒即可完成 ([ChatGPT 提示词](https://chatgpt.com/share/6834a1eb-b8fc-8005-a555-045a3986aeec))：\n\n\n::: {.callout-tip}\n### 提示词\n\n目标：定义一个函数 `read_files_in_folder(folder_path, Fname=None)`，用于批量读取指定文件夹下的 .xlsx 文件，并返回数据框和变量名-中文名字典。\n\n要求：\n\n1. 参数说明：\n    - `folder_path`：字符串，指定要读取的文件夹路径。\n    - `Fname`：字符串，可选，指定数据框和字典的名称前缀。若为 None，则自动取 .xlsx 文件名（不含扩展名），并将特殊字符替换为下划线。\n2. 处理流程：\n    - 检查文件夹下以 `.xlsx` 结尾且不以 `~$` 开头的文件，若数量不为 1，则报错。\n    - 将 .xlsx 文件转换为 .csv 文件（如已存在则跳过），转换时编码为 gbk。\n    - 读取 .csv 文件前 4 行，提取英文变量名和中文变量名。\n    - 对英文变量名，若为 'A-B' 结构，则只保留 B 部分。\n    - 构建 {英文变量名: 中文变量名} 的字典。\n    - 跳过前 4 行读取正文数据，列名用处理后的英文变量名。\n    - 返回一个 dict，包含数据框（键名为 `df_{Fname}`）和变量名字典（键名为 `dic_{Fname}`）。\n3. 代码需包含必要的 import，且不重复导入已在 notebook 其他 cell 导入的模块。\n4. 代码块必须完整、可直接运行。\n\n:::\n\n## 定义函数以批量读取指定文件夹下的文件\n\n几个要点：\n\n- 这个提示词还需修改：目前的提示词不具有独立性，应该与上一个 Cell 的提示词合并。\n- 变量名的处理：在 '利润表-现金流量表xxx.csv' 和 '资产负债表xxx.csv' 文件中，变量名的格式为 'A-B'，我们需要删除 'A-' 部分，只保留 'C' 部分。\n  - `FS_Combas-A001101000: 货币资金` 变为 `A001101000: 货币资金`\n  - `FS_Comins-B003000000: 基本每股收益` 变为 `B003000000: 基本每股收益`\n  - `FS_Comscfd-C001021000: 支付的各项税费` 变为 `C001021000: 支付的各项税费`\n\n::: {.callout-tip}\n### 提示词\n\n- 以 {tag}: 'read_xlsx_example' Cell 中的代码为基础，定义一个函数 `read_files_in_folder(folder_path, Fname)`，用于批量读取指定文件夹下的所有文件。\n  - 函数参数 `folder_path` 是一个字符串，表示要读取的文件夹路径。\n  - `Fname` 是一个字符串，表示文件夹的名称，用于生成数据框和字典的名称。如果用户不指定，则默认使用 `.xlsx` 文件的名称，特殊字符采用 `_` 替换，确保符合 Python 命名规则。\n  - 如果变量名为 `A-B` 结构，则删除 'A-' 部分，只保留 'B' 部分。\n- 函数返回：一个数据框，名称为 `df_{Fname}`；一个字典，用于存储 {变量名: 变量中文简称}，名称为 `dic_{Fname}`。\n\n:::\n\n## 批量处理\n\n接下来，我们就可以用上面定义的函数来批量处理 `data_raw` 文件夹中的所有子文件夹了。\n\n::: {.callout-tip}\n### 提示词\n\n用 {tag}: 'fcn_read_files_in_folder' Cell 中定义的 `read_files_in_folder()` 函数批量读取 `data_raw` 文件夹中的所有子文件夹下的文件，并将结果存储到 `data_clean` 文件夹中。主要步骤如下：\n\n- 如果 `data_clean` 文件夹不存在，则创建该文件夹；如果已经存在，则清空该文件夹中的所有内容。\n- 遍历 `data_raw` 文件夹中的所有子文件夹。\n  - 对于每个子文件夹，调用 `read_files_in_folder` 函数，读取其中的 `.xlsx` 文件和 `.txt` 文件。\n  - 将读取到的数据框和字典保存到 `data_clean` 文件夹中，文件名为 `{子文件夹名称}.pkl`。\n\n:::\n\n### 查看导入结果\n\n::: {.callout-tip}\n### 提示词\n\n列出 `data_clean` 文件夹中的所有文件，以及每个文件的对应字典的前五个 {key: value}\n\n:::\n\n简要分析：\n\n考虑到随后要将这些文件合并为一个数据框，我们需要重点关注如下几点：\n\n- `上市公司基本信息变更表2000-2024.pkl` 暂时用不到，不予处理。\n- 哪些文件需要纵向合并 (append)?\n  - `利润表-现金流量表-xxx.pkl` 和 `资产负债表-xxx.pkl` 这两类文件需要纵向合并，分别存入数据框 `df_profit` 和 `df_asset` 中。\n- 哪些文件需要横向合并 (merge)?\n  - 将 `df_profit` 和 `df_asset` 横向合并为一个数据框 `df_financial`；\n  - 进而与 `CSMAR常用变量-2000-2024.pkl` 和 `上市公司基本信息年度表.pkl` 横向合并，得到最终的数据框 `df_final`。\n- 横向合并时，需要保证两份数据中有相同的变量名 (keys)。由于我们要合并的数据都是 'firm-year' 格式的面板数据，因此需要保证每个数据框中都有 'code' 和 'year' 这两个变量。\n  - 我们需要为 `CSMAR常用变量-2000-2024.pkl` 和 `上市公司基本信息年度表.pkl` 这两份文件添加 'code'  和 'year' 变量。二者分别对应这三个数据文件中的 `Symbol` 和 `EndDate` 变量。\n  - 对于 `利润表-现金流量表-xxx.pkl` 和 `资产负债表-xxx` 文件，需要将 `EndDate` 变量转换为 `year` 变量，以便后续合并。\n\n### 查看处理后的单个文件\n\n::: {.callout-tip}\n### 提示词\n\n- 列示 'CSMAR常用变量-2000-2024.pkl' 中的所有对象；\n- 空一行+分隔线；\n- 列示 'CSMAR常用变量-2000-2024.pkl' 的 shape；\n- 空一行+分隔线；\n- 列示 'CSMAR常用变量-2000-2024.pkl' 数据框中的 '前五行+前五列'；\n- 空一行+分隔线；\n- 列示字典中的所有 {变量名：中文简称}。\n\n:::\n\n## 合并数据\n\n### 纵向合并\n\n::: {.callout-tip}\n### 提示词\n\n== 纵向合并不同年度的同名文件\n\n- 纵向合并 `data_clean` 文件夹中所有以 '资产负债表' 开头的文件。\n  - 将 `EndDate` 列重命名为 `year` 列。\n  - 合并后的数据框命名为 `df_assets`，并保存到 `data_clean` 文件夹中，文件名为 `df_assets.pkl`。\n- 纵向合并 `data_clean` 文件夹中所有以 '利润表' 开头的文件。\n  - 将 `EndDate` 列重命名为 `year` 列。\n  - 合并后的数据框命名为 `df_profit`，并保存到 `data_clean` 文件夹中，文件名为 `df_profit.pkl`。\n- 上述合并完成后，打印合并后的数据框的 shape；展示 '前三行 + 前五列'。\n\n:::\n\n### 横向合并\n\n::: {.callout-tip}\n### 提示词\n\n== 横向合并不同来源的数据\n\n1. 一些出现两次以上的功能，可以预先定义函数，确保代码结构清晰\n2. 资产负债表与利润表的合并\n  - 读入 `data_clean` 文件夹中的 `df_assets.pkl`。\n  - 按照关键词 '{code, year}' 与 `df_profit.pkl` 数据框横向合并；\n    - 如果有同名变量，则自动忽略。\n  - 合并后的数据存入数据框 `df_financial`;\n  - 数据框的前两列变量为 'code, year'\n3. 继续与 `上市公司基本信息年度表`, `CSMAR常用变量-2000-2024.pkl` 数据框横向合并。\n  - 合并前，先将 `上市公司基本信息年度表.pkl` 中的 `Symbol` 列重命名为 `code`，`EndDate` 列重命名为 `year`。\n  - 按照关键词 '{code, year}' 与 `df_financial` 数据框横向合并；\n    - 如果有同名变量，则自动忽略。\n4. 输出合并后的数据文件\n  - 合并后的数据存入数据框 `df_final`，\n    - 第一列为 'code'，第二列为 'year'，是两个独立的变量。\n    - 保存到 `data_clean` 文件夹中，文件名为 `df_final.pkl`。\n  - 最终数据框 `df_final` 的前两列变量为 'code, year'，并展示其 shape 和 '前三行 + 前五列'。\n5. 合并数据字典。将上述文件的字典合并为一个大字典 `dict_CSMAR`。\n  - 同名变量的中文简称和说明信息取先进入的文件的。 \n6. 打印数据字典尺寸，以及前十行信息，格式：{变量名: 中文简称}；\n7. 每组打印结果之间空一行，添加标题文字和分割线   \n\n:::\n\n### 输出最终数据文件\n\n::: {.callout-tip}\n### 提示词\n\n== 输出 csv 和 txt 文件到 [data_final] 文件夹\n\n1. 将 `df_final` 数据框保存为 `CSMAR_final.csv` 文件，存储在 [data_final] 文件夹中。\n2. 将 `dict_CSMAR` 字典保存为 `CSMAR_var_label.txt` 文件，存储在 [data_final] 文件夹中。每行格式为：`变量名: 中文简称`。\n\n:::\n\n### 收尾：删除无用文件和过程文件\n\n> Note：这一步是可选的，主要是为了清理不必要的文件，以节省存储空间和提高数据处理效率。  \n> 建议：确认所有数据处理和合并工作完成后，再执行此步骤。\n\n有些过程文件已经不需要了：\n\n-  `data_raw` 文件夹中的 `.xlsx` 文件已经转换为 `.csv` 文件，因此可以删除。\n-  `data_clean` 文件夹中的一些文件也不需要了，如 `利润表-现金流量表-xxx.pkl` 和 `资产负债表-xxx.pkl`，因为它们已经被合并为 `df_financial.pkl`。\n\n\n::: {.callout-tip}\n### 提示词\n\n- 删除 `data_raw` 文件夹中所有子文件夹中的 `.xlsx` 文件。\n- 删除 `data_clean` 文件夹中如下文件：\n  - 以 `利润表-现金流量表-` 开头的文件；\n  - 以 `资产负债表-` 开头的文件；\n  \n:::\n\n### 呈现项目文档树\n\n要点：\n\n- 代码执行后会自动将工作目录切换回项目根目录，确保后续操作路径一致。\n\n::: {.callout-tip}\n### 提示词\n\n- 列示项目文档树结构。\n- 只列示文件夹名称和文件名称，不需要显示文件内容。\n- 如果文件夹中有子文件夹，则显示子文件夹名称。\n- 处理完后，将工作目录切换到项目根目录。\n- 为此代码块添加标题和合适的注释。\n\n:::\n\n### 保留哪些文件夹？\n\n在本地运行完毕后，项目根目录下会包含如下文件夹：\n\n- [1] `data_raw_zip` 文件夹：**务必保留**，里面存放了从 CSMAR 下载的原始数据压缩包。\n- [2] `data_raw` 文件夹：**可以删除**，里面存放了解压后的 .xlsx 和 .txt 文档\n- [3] `data_clean` 文件夹：**酌情删除**，里面存放了清洗后的 `.pkl` 文件。\n- [4] `data_final` 文件夹：**建议保留**，里面存放了最终的 `.csv` 和 `.txt` 文件。\n\n可复现文档分享方案：\n\n一旦确定上述代码无误，在分享时，只需保留 `01_read_merge.ipynb` 文件和 `[data_raw_zip]` 文件夹即可。\n\n- 完整复现文档：\n  - `01_read_merge.ipynb` 文件：包含了从数据读取到合并的完整代码。\n  - `[data_raw_zip]` 文件夹：包含了从 CSMAR 下载的原始数据压缩包。\n- 直接使用最终文档 + 了解处理过程：\n  - `data_final` 文件夹：包含了最终的 `.csv` 和 `.txt` 文件，便于直接使用。\n  - `01_read_merge.ipynb` 文件：包含了从数据读取到合并的完整代码。\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"number-sections":true,"highlight-style":"atom-one","css":["../../styles.css"],"output-file":"01_unzip_to_csv.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.39","editor":"visual","theme":"cosmo","linestretch":1.6,"fontsize":"11.5pt","highlight":true,"callout-appearance":"default","md-extensions":["callout"],"title":"CSMAR 数据处理"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}